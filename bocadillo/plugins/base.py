from contextlib import contextmanager
import re
import inspect
from typing import Any, Callable, Dict, NamedTuple

PLUGIN_NAME_REGEX = re.compile(r"(.*)Plugin$")
REQUIRED = object()
UNDEFINED = object()


class Ref(NamedTuple):
    source: str


class PluginMeta(type):
    def __new__(mcs, name, bases, namespace):
        base = namespace.pop("__base__", False)

        cls = super().__new__(mcs, name, bases, namespace)

        if not base:
            cls.name = mcs.get_name(cls)
            cls.extract_settings = mcs.get_settings_extractor(cls.apply)

        return cls

    @classmethod
    def get_name(mcs, cls) -> str:
        try:
            return cls.name
        except AttributeError:
            match = PLUGIN_NAME_REGEX.match(cls.__name__)
            if not match:
                raise ValueError(
                    f"Cannot infer name of plugin {cls}. "
                    "Use the '*Plugin' naming convention "
                    "or set the `name` class attribute."
                )
            return match.group(1)

    @classmethod
    def get_settings_extractor(mcs, apply: Callable) -> Callable:
        config = {}

        sig = inspect.signature(apply)

        for name, param in sig.parameters.items():
            if name in ("self", "app"):
                continue

            if param.kind is inspect.Parameter.VAR_KEYWORD:
                continue

            if param.default is inspect.Parameter.empty:
                config[name] = REQUIRED
            else:
                config[name] = param.default

        def extract(settings: Any) -> dict:
            extracted: Dict[str, Any] = {}
            refs: Dict[str, str] = {}

            for key, default in config.items():
                if default is REQUIRED:
                    value = getattr(settings, key.upper())
                else:
                    value = getattr(settings, key.upper(), default)

                    if value == default and isinstance(default, Ref):
                        refs[key] = default.source
                        continue

                extracted[key] = value

            for key, source in refs.items():
                extracted[key] = extracted[source]

            return extracted

        return staticmethod(extract)


class Plugin(metaclass=PluginMeta):

    __base__ = True

    name: str
    apply_if_set: str

    # Generated by metaclass based on the signature of `.apply()`.
    extract_settings: Callable[[Any], dict]

    def __init__(self):
        self.configured_apps = set()

    @contextmanager
    def _register(self, app):
        if app in self.configured_apps:
            raise RuntimeError(f"{self.name} already configured on app {app}")
        yield
        self.configured_apps.add(app)

    def should_apply(self, settings: Any) -> bool:
        try:
            apply_if_set = self.apply_if_set
        except AttributeError:
            return True
        else:
            value = getattr(settings, apply_if_set, UNDEFINED)
            return value not in (UNDEFINED, False)

    def apply(self, app, **kwargs) -> None:
        pass

    def __call__(self, app, settings) -> None:
        if app in self.configured_apps:
            return

        if not self.should_apply(settings):
            return

        settings: dict = self.extract_settings(settings)
        self.apply(app, **settings)

        self.configured_apps.add(app)
